import { minimatch } from "minimatch";
import { joinURL, withoutLeadingSlash } from "ufo";
import { hash } from "ohash";
import { getOrderedSchemaKeys } from "../schema.js";
import { parseSourceBase } from "./utils.js";
import { withoutRoot } from "./files.js";
export const getCollectionByFilePath = (path, collections) => {
  let matchedSource;
  const collection = Object.values(collections).find((collection2) => {
    if (!collection2.source || collection2.source.length === 0) {
      return;
    }
    const pathWithoutRoot = withoutRoot(path);
    const paths = pathWithoutRoot === "/" ? ["index.yml", "index.yaml", "index.md", "index.json"] : [pathWithoutRoot];
    return paths.some((p) => {
      matchedSource = collection2.source.find((source) => minimatch(p, source.include) && !source.exclude?.some((exclude) => minimatch(p, exclude)));
      return matchedSource;
    });
  });
  return {
    collection,
    matchedSource
  };
};
export const getCollectionByRoutePath = (routePath, collections) => {
  let matchedSource;
  const collection = Object.values(collections).find((collection2) => {
    if (!collection2.source || collection2.source.length === 0) {
      return;
    }
    matchedSource = collection2.source.find((source) => {
      if (!source.prefix || !routePath.startsWith(source.prefix)) {
        return;
      }
      if (routePath === "/" || routePath === source.prefix) {
        const indexFiles = ["index.yml", "index.yaml", "index.md", "index.json"];
        const files = routePath === "/" ? indexFiles : indexFiles.map((file) => withoutLeadingSlash(joinURL(source.prefix, file)));
        return files.some((p) => {
          return collection2.source.find((source2) => minimatch(p, source2.include) && !source2.exclude?.some((exclude) => minimatch(p, exclude)));
        });
      }
      const pathWithoutPrefix = routePath.substring(source.prefix.length);
      const { fixed } = parseSourceBase(source);
      const path = joinURL(fixed, pathWithoutPrefix);
      const removeExtension = (pattern) => {
        return pattern.replace(/\.[^/.]+$/, "");
      };
      return minimatch(path, removeExtension(source.include)) && !source.exclude?.some((exclude) => minimatch(path, removeExtension(exclude)));
    });
    return matchedSource;
  });
  return {
    collection,
    matchedSource
  };
};
export function generateCollectionInsert(collection, data) {
  const values = computeValuesBasedOnCollectionSchema(collection, data);
  let index = 0;
  return `INSERT INTO ${collection.tableName} VALUES (${"?, ".repeat(values.length).slice(0, -2)})`.replace(/\?/g, () => values[index++]);
}
export function generateRecordUpdate(collection, stem, data) {
  const deleteQuery = generateRecordDeletion(collection, stem);
  const insertQuery = generateCollectionInsert(collection, data);
  return `${deleteQuery}; ${insertQuery}`;
}
export function generateRecordDeletion(collection, stem) {
  return `DELETE FROM ${collection.tableName} WHERE stem = '${stem}';`;
}
export function generateRecordSelectByColumn(collection, column, value) {
  return `SELECT * FROM ${collection.tableName} WHERE ${column} = '${value}';`;
}
function computeValuesBasedOnCollectionSchema(collection, data) {
  const fields = [];
  const values = [];
  const properties = collection.schema.definitions[collection.name].properties;
  const sortedKeys = getOrderedSchemaKeys(properties);
  sortedKeys.forEach((key) => {
    const value = properties[key];
    const underlyingType = value.type;
    const defaultValue = value.default !== void 0 ? value.default : "NULL";
    const valueToInsert = typeof data[key] !== "undefined" ? data[key] : defaultValue;
    fields.push(key);
    if (collection.fields[key] === "json") {
      values.push(`'${JSON.stringify(valueToInsert).replace(/'/g, "''")}'`);
    } else if (["string", "enum"].includes(underlyingType)) {
      values.push(`'${String(valueToInsert).replace(/\n/g, "\\n").replace(/'/g, "''")}'`);
    } else {
      values.push(valueToInsert);
    }
  });
  values.push(`'${hash(values)}'`);
  return values;
}
